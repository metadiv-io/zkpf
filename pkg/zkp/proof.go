package zkp

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"math/big"

	"github.com/blockchain-research/crypto/bn256"
	"github.com/metadiv-io/zkpf/pkg/ccs08"
)

func GenerateRangeProof(minValue, maxValue, secret int) ProofResult {
	prover, verifier, err := ccs08.Setup(int64(minValue), int64(maxValue))
	if err != nil {
		fmt.Println("failed to setup")
	}

	r, _ := rand.Int(rand.Reader, bn256.Order)
	x := new(big.Int).SetInt64(int64(secret))

	// Proof generated by prover
	proof, err := prover.Prove(x, r)
	if err != nil {
		fmt.Println("failed to prove")
	}

	proof1Base64 := base64.StdEncoding.EncodeToString(proof.Proof1.Marshal())
	proof2Base64 := base64.StdEncoding.EncodeToString(proof.Proof2.Marshal())

	// verifier verify the proof
	result, err := verifier.Verify(proof)
	if err != nil {
		fmt.Println("failed to verify")
	}
	verifierBase64 := base64.StdEncoding.EncodeToString(verifier.Marshal())

	return ProofResult{
		InRange:  result,
		MinValue: minValue,
		MaxValue: maxValue,
		RandNum:  int(r.Int64()),
		Verifier: verifierBase64,
		Proof1:   proof1Base64,
		Proof2:   proof2Base64,
	}
}

func VerifyProofResult(proofResult ProofResult) bool {
	proof1Bytes, _ := base64.StdEncoding.DecodeString(proofResult.Proof1)
	proof2Bytes, _ := base64.StdEncoding.DecodeString(proofResult.Proof2)
	verifierBytes, _ := base64.StdEncoding.DecodeString(proofResult.Verifier)

	proof := &ccs08.Proof{
		Proof1: new(ccs08.ProofUL),
		Proof2: new(ccs08.ProofUL),
	}
	ccs08.Unmarshal(proof1Bytes, proof.Proof1)
	ccs08.Unmarshal(proof2Bytes, proof.Proof2)

	verifier := new(ccs08.Verifier)
	verifier.Unmarshal(verifierBytes)

	result, err := verifier.Verify(proof)
	if err != nil {
		fmt.Println("failed to verify")
		return false
	}
	return result == proofResult.InRange
}

func VerifyProofResultWithSecret(proofResult ProofResult, secret int) bool {
	if !VerifyProofResult(proofResult) {
		return false
	}
	newProofResult := GenerateRangeProof(proofResult.MinValue, proofResult.MaxValue, secret)
	return newProofResult.InRange == proofResult.InRange
}
